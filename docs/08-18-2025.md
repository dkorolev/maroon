# Project Notes

## 08-18-2025

### 1. Naming
The term *singleton* is probably not a good fit — *daemon* seems more appropriate.  

### 2. Worker pools
In the future we may potentially have worker pools. A fiber can be turned into a daemon multiple times.  

### 3. Fiber daemon initialization
It seems reasonable to implement this by simply initializing the heap contents for each instance of a fiber daemon from the IR.  

For example, if we have four worker fibers and we want them to know their indices, then in the IR for this fiber’s `daemon` field we can just store an array of four elements:  

```json
[{idx:0}, {idx:1}, {idx:2}, {idx:3}]
```

This array becomes heap content that is strictly type-correct for the corresponding fiber.  

Details are TBD — possibly the IR will need to be split into several files:  
- the main IR containing the schema  
- separate data files conforming to this schema  

### 4. Assembler / low-level DSL
We will indeed write an assembler (i.e. a low-level DSL).  

If we agree, for example, that a function’s return value is always placed “above” its state on the stack, then a function `add_one` for an `i64` argument might look like:  

```
i64_add_and_assign [retval], [arg0], 1;
ret
```

Here:
- `[retval]` is equivalent to `[sp-2]`  
- `[arg0]` is equivalent to `[sp-1]`  

At `[sp]` lies the state, at `[sp-1]` the argument, and `[sp-2]` is reserved for the result.  

The `ret` instruction is effectively `ret {-1}`, since we must tell the maroon engine to drop exactly one local variable from the stack.  

In practice we may not need to write this explicitly — the DSL transpiles into a flat/nested set of steps, and the maroon assembler analyzer can automatically determine how far the stack should be unwound.  

### 5. Global fiber
Instead of inventing global queue names, we can define a single global (or `world`) fiber with its own heap, which must be initialized.  

This approach seems to solve the problem in a universal way.  

In this setup we can also define “global” functions that can be called from any fiber (which will definitely be needed).  

### 6. Futures and queues
We realized that all futures and all queues will need to be global, since they can be passed by reference between fibers.  

In fact, a future is just a special case of a queue: it supports exactly one `publish`, which sets its value.  

### 7. Cancellation tokens
By design, each future/queue either contains or can contain a cancellation token.  

- A future can be created on the stack and never awaited.  
- A future can be created on the heap and later deleted.  
- If a future is stored inside a container (e.g. as a field of a map value), then removing the key automatically deletes the future.  

### 8. Safety guarantees
At the maroon engine level there will be many runtime checks.  
Our low-level DSL provides static guarantees that we won’t “shoot ourselves in the foot”:  

- we can’t unwind the stack by the wrong number of steps  
- we can’t access memory belonging to another fiber  
- we can’t set the same future twice (if it’s truly a `Future`, setting it twice should be a static typing error detected at DSL static analysis time)  
